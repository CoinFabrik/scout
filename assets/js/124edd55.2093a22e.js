"use strict";(self.webpackChunkscout=self.webpackChunkscout||[]).push([[4205],{9613:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>m});var a=n(9496);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),c=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},u=function(e){var t=c(e.components);return a.createElement(s.Provider,{value:t},e.children)},d="mdxType",h={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},p=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),d=c(n),p=r,m=d["".concat(s,".").concat(p)]||d[p]||h[p]||i;return n?a.createElement(m,o(o({ref:t},u),{},{components:n})):a.createElement(m,o({ref:t},u))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=p;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[d]="string"==typeof e?e:r,o[1]=l;for(var c=2;c<i;c++)o[c]=n[c];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}p.displayName="MDXCreateElement"},8210:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>h,frontMatter:()=>i,metadata:()=>l,toc:()=>c});var a=n(2564),r=(n(9496),n(9613));const i={sidebar_position:2},o="Vulnerabilities",l={unversionedId:"vulnerabilities/README",id:"vulnerabilities/README",title:"Vulnerabilities",description:"This section lists relevant security-related issues typically introduced during the development of smart contracts in Substrate Ink!. While many of these issues can be generalized to Substrate-based networks, that is not always the case. The list, though non-exhaustive, features highly relevant items. Each issue is assigned a severity label based on the taxonomy presented below.",source:"@site/docs/vulnerabilities/README.md",sourceDirName:"vulnerabilities",slug:"/vulnerabilities/",permalink:"/scout/docs/vulnerabilities/",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/vulnerabilities/README.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"docsSidebar",previous:{title:"Getting Started",permalink:"/scout/docs/intro"},next:{title:"Integer overflow and integer underflow",permalink:"/scout/docs/vulnerabilities/integer-overflow-or-underflow"}},s={},c=[{value:"Vulnerability Severity",id:"vulnerability-severity",level:2},{value:"Vulnerability Categories",id:"vulnerability-categories",level:2},{value:"Vulnerability Classes",id:"vulnerability-classes",level:2},{value:"1 - Integer Overflow and Integer Underflow",id:"1---integer-overflow-and-integer-underflow",level:3},{value:"2 - Unauthorized Set Contract Storage",id:"2---unauthorized-set-contract-storage",level:3},{value:"3 - Reentrancy",id:"3---reentrancy",level:3},{value:"4 - Panic error",id:"4---panic-error",level:3},{value:"5 - Unused Return enum",id:"5---unused-return-enum",level:3},{value:"6 - DoS Unbounded Operation",id:"6---dos-unbounded-operation",level:3},{value:"7 - DoS Unexpected Revert With Vector",id:"7---dos-unexpected-revert-with-vector",level:3}],u={toc:c},d="wrapper";function h(e){let{components:t,...n}=e;return(0,r.kt)(d,(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"vulnerabilities"},"Vulnerabilities"),(0,r.kt)("p",null,"This section lists relevant security-related issues typically introduced during the development of smart contracts in Substrate Ink!. While many of these issues can be generalized to Substrate-based networks, that is not always the case. The list, though non-exhaustive, features highly relevant items. Each issue is assigned a severity label based on the taxonomy presented below."),(0,r.kt)("h2",{id:"vulnerability-severity"},"Vulnerability Severity"),(0,r.kt)("p",null,"This severity classification, although arbitrary, has been used in hundreds\nof security audits and helps to understand the vulnerabilities we introduce\nand measure the utility of this proof of concept."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Critical"),": These issues seriously compromise the system and must be addressed immediately."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Medium"),": These are potentially exploitable issues which might represent\na security risk in the near future. We suggest fixing them as soon as possible."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Minor"),": These issues represent problems that are relatively small or difficult to exploit, but might be exploited in combination with other issues. These kinds of issues do not block deployments in production environments. They should be taken into account and fixed when possible."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Enhancement"),": This class relates to issues stemming from deviations from best practices or stylistic conventions, which could escalate into higher-priority issues due to other changes. For instance, these issues may lead to development errors in future updates.")),(0,r.kt)("h2",{id:"vulnerability-categories"},"Vulnerability Categories"),(0,r.kt)("p",null,'We follow with a taxonomy of Vulnerabilities. Many "top vulnerability" lists\ncan be found covering Ethereum/Solidity smart contracts. This list below is\nused by the Coinfabrik Audit Team, when source code (security) audits in\nEthereum/Solidity, Stacks/Clarity, Algorand/PyTEAL /TEAL, Solana/RUST, etc.\nThe team discusses the creation of the list in this\n',(0,r.kt)("a",{parentName:"p",href:"https://blog.coinfabrik.com/analysis-categories/"},"blogpost"),"."),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Category"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Arithmetic"),(0,r.kt)("td",{parentName:"tr",align:null},"Proper usage of arithmetic and number representation.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Assembly Usage"),(0,r.kt)("td",{parentName:"tr",align:null},"Detailed analysis of implementations using assembly.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Authorization"),(0,r.kt)("td",{parentName:"tr",align:null},"Vulnerabilities related to insufficient access control or incorrect authorization implementation.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Best practices"),(0,r.kt)("td",{parentName:"tr",align:null},"Conventions and best practices for improved code quality and vulnerability prevention.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Block attributes"),(0,r.kt)("td",{parentName:"tr",align:null},"Appropriate usage of block attributes, especially when used as a source of randomness.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Centralization"),(0,r.kt)("td",{parentName:"tr",align:null},"Analysis of centralization and single points of failure.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"DoS"),(0,r.kt)("td",{parentName:"tr",align:null},"Denial of service attacks.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Gas Usage"),(0,r.kt)("td",{parentName:"tr",align:null},"Performance issues, enhancements and vulnerabilities related to use of gas.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"MEV"),(0,r.kt)("td",{parentName:"tr",align:null},"Patterns that could lead to the exploitation of Maximal Extractable Value.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Privacy"),(0,r.kt)("td",{parentName:"tr",align:null},"Patterns revealing sensible user or state data.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Reentrancy"),(0,r.kt)("td",{parentName:"tr",align:null},"Consistency of contract state under recursive calls.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Unexpected transfers"),(0,r.kt)("td",{parentName:"tr",align:null},"Contract behavior under unexpected or forced transfers of tokens.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Upgradability"),(0,r.kt)("td",{parentName:"tr",align:null},"Proxy patterns and upgradable smart contracts.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Validations and error handling"),(0,r.kt)("td",{parentName:"tr",align:null},"Handling of errors, exceptions and parameters.")))),(0,r.kt)("p",null,"We used the above Vulnerability Categories, along with common examples of vulnerabilities detected within each category in other blockchains, as a guideline for finding and developing vulnerable examples of Substrate Ink! smart contracts."),(0,r.kt)("h2",{id:"vulnerability-classes"},"Vulnerability Classes"),(0,r.kt)("p",null,"As a result of our research, we have so far identified seven types of vulnerabilities that fall under the six following different vulnerability categories (so two types fall under one category): Arithmetic, Authorization, Denial of Service, Reentrancy, and Validations and Error Handling."),(0,r.kt)("p",null,"What follows is a description of each vulnerability in the context of ink! smart contracts. In each case, we have produced a smart contract exposing one of these vulnerabilities."),(0,r.kt)("p",null,"Check our\n",(0,r.kt)("a",{parentName:"p",href:"https://github.com/CoinFabrik/scout/tree/main/test-cases"},"test-cases"),"\nfor code examples of these vulnerabilities"),(0,r.kt)("h3",{id:"1---integer-overflow-and-integer-underflow"},"1 - Integer Overflow and Integer Underflow"),(0,r.kt)("p",null,"This type of vulnerability occurs when an arithmetic operation attempts to\ncreate a numeric value that is outside the valid range in substrate, e.g,\na ",(0,r.kt)("inlineCode",{parentName:"p"},"u8")," unsigned integer can be at most ",(0,r.kt)("em",{parentName:"p"},"M:=2^8-1=255"),", hence the sum ",(0,r.kt)("inlineCode",{parentName:"p"},"M+1"),"\nproduces an overflow. "),(0,r.kt)("p",null,"An overflow/underflow is typically caught and generates an error. When it\nis not caught, the operation will result in an inexact result which could\nlead to serious problems. We classified this type of vulnerability under\nthe ",(0,r.kt)("a",{parentName:"p",href:"#vulnerability-categories"},"Arithmetic Category")," type and assinged it a\nCritical Severity."),(0,r.kt)("p",null,"In the context of Substrate, we found that this vulnerability could only be\nrealized if overflow and underflow checks are disabled during compilation.\nNotwithstanding, there are contexts where developers do turn off checks for\nvalid reasons and hence the reason for including this vulnerability in the\nlist. "),(0,r.kt)("p",null,"Check the following ",(0,r.kt)("a",{parentName:"p",href:"/scout/docs/vulnerabilities/integer-overflow-or-underflow"},"documentation")," for a more detailed explanation of this vulnerability class."),(0,r.kt)("h3",{id:"2---unauthorized-set-contract-storage"},"2 - Unauthorized Set Contract Storage"),(0,r.kt)("p",null,"Smart contracts can store important information in memory which changes through the contract's lifecycle. Changes happen via user interaction with the smart contract. An ",(0,r.kt)("em",{parentName:"p"},"unauthorized")," set contract storage vulnerability happens when a smart contract call allows a user to set or modify contract memory when they were not supposed to be authorized."),(0,r.kt)("p",null,"Common practice is to have functions with the ability to change\nsecurity-relevant values in memory to be only accessible to specific roles,\ne.g, only an admin can call the function ",(0,r.kt)("inlineCode",{parentName:"p"},"reset()")," which resets auction values.\nWhen this does not happen, arbitrary users may alter memory which may impose\ngreat damage to the smart contract users. We classified this vulnerability\nunder the ",(0,r.kt)("a",{parentName:"p",href:"#vulnerability-categories"},"Authorization Category")," and assigned it a\nCritical Severity."),(0,r.kt)("p",null,"In ",(0,r.kt)("inlineCode",{parentName:"p"},"ink!")," the function ",(0,r.kt)("inlineCode",{parentName:"p"},"set_contract_storage(key: &K, value: &V)")," can be used\nto modify the contract storage under a given key. When a smart contract uses\nthis function, the contract needs to check if the caller should be able to\nalter this storage. If this does not happen, an arbitary caller may modify\nbalances and other relevant contract storage."),(0,r.kt)("p",null,"Check the following ",(0,r.kt)("a",{parentName:"p",href:"/scout/docs/vulnerabilities/set-contract-storage"},"documentation")," for a more detailed explanation of this vulnerability class."),(0,r.kt)("h3",{id:"3---reentrancy"},"3 - Reentrancy"),(0,r.kt)("p",null,"An ",(0,r.kt)("inlineCode",{parentName:"p"},"ink!")," smart contract can interact with other smart contracts. These\noperations imply (external) calls where control flow is passed to the called\ncontract until the execution of the called code is over, then the control is\ndelivered back to the caller. A ",(0,r.kt)("em",{parentName:"p"},"reentrancy")," vulnerability may happen when a\nuser calls a function, this function calls a malicious contract which again\ncalls this same function, and this 'reentrancy' has unexpected reprecussions\nto the contract.\nThis kind of attack was used in Ethereum for\n",(0,r.kt)("a",{parentName:"p",href:"https://www.economist.com/finance-and-economics/2016/05/19/the-dao-of-accrue"},"the infamous DAO Hack"),"."),(0,r.kt)("p",null,"This vulnerability may be prevented with the use of the Check-Effect-Interaction\npattern that dictates that we first evaluate (check) if the necessary conditions\nare granted, next we record the effects of the interaction and finally we\nexecute the interaction (e.g., check if the user has funds, substract the funds\nfrom the records, then transfer the funds). There's also so-called\n",(0,r.kt)("em",{parentName:"p"},"reentrancy guards")," which prevent the marked piece of code to be called twice\nfrom the same contract call. When the vulnerability may be exercised, the\nsuccessive calls to the contract may allow the malicious contract to execute a\nfunction partially many times, e.g., transfering funds many times but\nsubstracting the funds only once.\nThis vulnerability is of the ",(0,r.kt)("a",{parentName:"p",href:"#vulnerability-categories"},"Reentrancy Category")," and\nassign it a Critical Severity."),(0,r.kt)("p",null,"In the context of ",(0,r.kt)("inlineCode",{parentName:"p"},"ink!")," Substrate smart contracts there are controls\npreventing reentrancy which could be turned off (validly) using the flag\n",(0,r.kt)("inlineCode",{parentName:"p"},"set_allow_reentry(true)"),"."),(0,r.kt)("p",null,"Check the following ",(0,r.kt)("a",{parentName:"p",href:"/scout/docs/vulnerabilities/reentrancy"},"documentation")," for a more detailed explanation of this vulnerability class."),(0,r.kt)("h3",{id:"4---panic-error"},"4 - Panic error"),(0,r.kt)("p",null,"The use of the ",(0,r.kt)("inlineCode",{parentName:"p"},"panic!")," macro to stop execution when a condition is not met is\nuseful for testing and prototyping but should be avoided in production code.\nUsing ",(0,r.kt)("inlineCode",{parentName:"p"},"Result")," as the return type for functions that can fail is the idiomatic\nway to handle errors in Rust."),(0,r.kt)("p",null,"We classified this issue, a deviation for best practices which could have\nsecurity implications, under the ",(0,r.kt)("a",{parentName:"p",href:"#vulnerability-categories"},"Validations and Error Handling Category"),"\nwith the severity of an Enhancement."),(0,r.kt)("p",null,"Check the following ",(0,r.kt)("a",{parentName:"p",href:"/scout/docs/vulnerabilities/panic-error"},"documentation")," for a more detailed explanation of this vulnerability class."),(0,r.kt)("h3",{id:"5---unused-return-enum"},"5 - Unused Return enum"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Ink!")," messages can return a ",(0,r.kt)("inlineCode",{parentName:"p"},"Result")," ",(0,r.kt)("inlineCode",{parentName:"p"},"enum")," with a custom error type. This is\nuseful for the caller to know what went wrong when the message fails. The\ndefinition of the ",(0,r.kt)("inlineCode",{parentName:"p"},"Result")," type enum consists of two variants: Ok and Err. If\nany of the variants is not used, the code could be simplified or it could imply\na bug."),(0,r.kt)("p",null,"We put this vulnerability under the ",(0,r.kt)("a",{parentName:"p",href:"#vulnerability-categories"},"Validations and Error Handling Category"),"\nwith a Minor Severity."),(0,r.kt)("p",null,"In our example, we see how lack of revision on the usage of both types (",(0,r.kt)("inlineCode",{parentName:"p"},"Ok"),"\nand ",(0,r.kt)("inlineCode",{parentName:"p"},"Err"),") leads to code where its intended functionality is not realized."),(0,r.kt)("p",null,"Check the following ",(0,r.kt)("a",{parentName:"p",href:"/scout/docs/vulnerabilities/unused-return-enum"},"documentation")," for a more detailed explanation of this vulnerability class."),(0,r.kt)("h3",{id:"6---dos-unbounded-operation"},"6 - DoS Unbounded Operation"),(0,r.kt)("p",null,"Each block in a Substrate Blockchain has an upper bound on the amount of gas\nthat can be spent, and thus the amount of computation that can be done. This\nis the Block Gas Limit. If the gas spent by a function call on an ",(0,r.kt)("inlineCode",{parentName:"p"},"ink!")," smart\ncontract exceeds this limit, the transaction will fail. Sometimes it is the\ncase that the contract logic allows a malicious user to modify conditions\nso that other users are forced to exhaust gas on standard function calls."),(0,r.kt)("p",null,"In order to prevent a single transaction from consuming all the gas in a block,\nunbounded operations must be avoided. This includes loops that do not have a\nbounded number of iterations, and recursive calls. This vulnerability falls\nunder the ",(0,r.kt)("a",{parentName:"p",href:"#vulnerability-categories"},"Denial of Service Category")," and has a Medium\nSeverity.\nA denial of service vulnerability allows the exploiter to hamper the\navailability of a service rendered by the smart contract. In the context\nof ",(0,r.kt)("inlineCode",{parentName:"p"},"ink!")," smart contracts, it can be caused by the exhaustion of gas,\nstorage space, or other failures in the contract's logic."),(0,r.kt)("p",null,"Needless to say, there are many different ways to cause a DOS vulnerability.\nThis case is relevant and introduced repeatedly by the developer untrained in\nweb3 environments. "),(0,r.kt)("p",null,"Check the following ",(0,r.kt)("a",{parentName:"p",href:"/scout/docs/vulnerabilities/dos-unbounded-operation"},"documentation")," for a more detailed explanation of this vulnerability class."),(0,r.kt)("h3",{id:"7---dos-unexpected-revert-with-vector"},"7 - DoS Unexpected Revert With Vector"),(0,r.kt)("p",null,"Another type of Denial of Service attack is called unexpected revert. It occurs\nby preventing transactions by other users from being successfully executed\nforcing the blockchain state to revert to its original state."),(0,r.kt)("p",null,"This vulnerability again falls under the ",(0,r.kt)("a",{parentName:"p",href:"#vulnerability-categories"},"Denial of Service Category"),"\nand similarly has a Medium Severity."),(0,r.kt)("p",null,"In this particular example, a Denial of Service through unexpected revert is\naccomplished by exploiting a smart contract that does not manage storage size\nerrors correctly. It can be prevented by using Mapping instead of Vec to avoid\nstorage limit problems."),(0,r.kt)("p",null,"Check the following ",(0,r.kt)("a",{parentName:"p",href:"/scout/docs/vulnerabilities/dos-unexpected-revert-with-vector"},"documentation")," for a more detailed explanation of this vulnerability class."))}h.isMDXComponent=!0}}]);