"use strict";(self.webpackChunkscout=self.webpackChunkscout||[]).push([[469],{9613:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>d});var i=n(9496);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,i,r=function(e,t){if(null==e)return{};var n,i,r={},a=Object.keys(e);for(i=0;i<a.length;i++)n=a[i],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(i=0;i<a.length;i++)n=a[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=i.createContext({}),u=function(e){var t=i.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},c=function(e){var t=u(e.components);return i.createElement(s.Provider,{value:t},e.children)},p="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},f=i.forwardRef((function(e,t){var n=e.components,r=e.mdxType,a=e.originalType,s=e.parentName,c=o(e,["components","mdxType","originalType","parentName"]),p=u(n),f=r,d=p["".concat(s,".").concat(f)]||p[f]||m[f]||a;return n?i.createElement(d,l(l({ref:t},c),{},{components:n})):i.createElement(d,l({ref:t},c))}));function d(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var a=n.length,l=new Array(a);l[0]=f;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o[p]="string"==typeof e?e:r,l[1]=o;for(var u=2;u<a;u++)l[u]=n[u];return i.createElement.apply(null,l)}return i.createElement.apply(null,n)}f.displayName="MDXCreateElement"},697:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>l,default:()=>m,frontMatter:()=>a,metadata:()=>o,toc:()=>u});var i=n(2564),r=(n(9496),n(9613));const a={},l="Insufficiently random values",o={unversionedId:"vulnerabilities/insufficiently-random-values",id:"vulnerabilities/insufficiently-random-values",title:"Insufficiently random values",description:"Description",source:"@site/docs/vulnerabilities/13-insufficiently-random-values.md",sourceDirName:"vulnerabilities",slug:"/vulnerabilities/insufficiently-random-values",permalink:"/scout/docs/vulnerabilities/insufficiently-random-values",draft:!1,editUrl:"https://github.com/CoinFabrik/scout/docs/vulnerabilities/13-insufficiently-random-values.md",tags:[],version:"current",sidebarPosition:13,frontMatter:{},sidebar:"docsSidebar",previous:{title:"Zero or test address",permalink:"/scout/docs/vulnerabilities/zero-or-test-address"},next:{title:"Insufficiently random values",permalink:"/scout/docs/vulnerabilities/unrestricted-transfer-from"}},s={},u=[{value:"Description",id:"description",level:2},{value:"Exploit Scenario",id:"exploit-scenario",level:2},{value:"Remediation",id:"remediation",level:2},{value:"References",id:"references",level:2}],c={toc:u},p="wrapper";function m(e){let{components:t,...n}=e;return(0,r.kt)(p,(0,i.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"insufficiently-random-values"},"Insufficiently random values"),(0,r.kt)("h2",{id:"description"},"Description"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Vulnerability Category: ",(0,r.kt)("inlineCode",{parentName:"li"},"Block attributes")),(0,r.kt)("li",{parentName:"ul"},"Vulnerability Severity: ",(0,r.kt)("inlineCode",{parentName:"li"},"Critical")),(0,r.kt)("li",{parentName:"ul"},"Detectors: ",(0,r.kt)("a",{parentName:"li",href:"https://github.com/CoinFabrik/scout/tree/main/detectors/insufficiently-random-values"},(0,r.kt)("inlineCode",{parentName:"a"},"insufficiently-random-values"))),(0,r.kt)("li",{parentName:"ul"},"Test Cases: ",(0,r.kt)("a",{parentName:"li",href:"https://github.com/CoinFabrik/scout/tree/main/test-cases/insufficiently-random-values/insufficiently-random-values-1"},(0,r.kt)("inlineCode",{parentName:"a"},"insufficiently-random-values-1")))),(0,r.kt)("p",null,"Using block attributes like ",(0,r.kt)("inlineCode",{parentName:"p"},"block_timestamp")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"block_number")," for random number generation in ink! Substrate smart contracts is not recommended due to the predictability of these values. Block attributes are publicly visible and deterministic, making it easy for malicious actors to anticipate their values and manipulate outcomes to their advantage. Furthermore, validators could potentially influence these attributes, further exacerbating the risk of manipulation. For truly random number generation, it's important to use a source that is both unpredictable and external to the blockchain environment, reducing the potential for malicious exploitation."),(0,r.kt)("h2",{id:"exploit-scenario"},"Exploit Scenario"),(0,r.kt)("p",null,"Consider the following ",(0,r.kt)("inlineCode",{parentName:"p"},"ink!")," contract:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"#[ink(message, payable)]\npub fn bet_single(&mut self, number: u8) -> Result<bool> {\n    let inputs = self.check_inputs(36, 0, 36, number);\n    if inputs.is_err() {\n        return Err(inputs.unwrap_err());\n    }\n\n    let pseudo_random: u8 = (self.env().block_number() % 37).try_into().unwrap();\n    if pseudo_random == number {\n        return self\n            .env()\n            .transfer(self.env().caller(), self.env().transferred_value() * 36)\n            .map(|_| true)\n            .map_err(|_e| Error::TransferFailed);\n    }\n    return Ok(false);\n}\n")),(0,r.kt)("p",null,"The vulnerability in this ",(0,r.kt)("inlineCode",{parentName:"p"},"bet_single")," function arises from the use of ",(0,r.kt)("inlineCode",{parentName:"p"},"self.env().block_number() % 37")," for pseudo-random number generation. Given the public visibility and predictability of block numbers, this method exposes the function to potential manipulation. "),(0,r.kt)("p",null,"The vulnerable code example can be found ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/CoinFabrik/scout/tree/main/test-cases/insufficiently-random-values/insufficiently-random-values-1/vulnerable-example"},(0,r.kt)("inlineCode",{parentName:"a"},"here")),"."),(0,r.kt)("h2",{id:"remediation"},"Remediation"),(0,r.kt)("p",null,"Avoid using block attributes like ",(0,r.kt)("inlineCode",{parentName:"p"},"block_timestamp")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"block_number")," for randomness generation, and consider using oracles instead."),(0,r.kt)("h2",{id:"references"},"References"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://dasp.co/#item-6"},"https://dasp.co/#item-6")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://blog.sigmaprime.io/solidity-security.html#SP-6"},"https://blog.sigmaprime.io/solidity-security.html#SP-6")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://swcregistry.io/docs/SWC-120"},"SWC-120")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://swcregistry.io/docs/SWC-116"},"SWC-116")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://ethernaut.openzeppelin.com/level/0x4dF32584890A0026e56f7535d0f2C6486753624f"},"Ethernaut: Coinflip")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://github.com/crytic/slither/wiki/Detector-Documentation#weak-PRNG"},"Slither: Weak PRNG")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://github.com/crytic/slither/wiki/Detector-Documentation#block-timestamp"},"Slither: Dangerous usage of block.timestamp"))))}m.isMDXComponent=!0}}]);