"use strict";(self.webpackChunkscout=self.webpackChunkscout||[]).push([[58],{9613:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>b});var a=n(9496);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var s=a.createContext({}),u=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=u(e.components);return a.createElement(s.Provider,{value:t},e.children)},p="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),p=u(n),m=o,b=p["".concat(s,".").concat(m)]||p[m]||d[m]||r;return n?a.createElement(b,i(i({ref:t},c),{},{components:n})):a.createElement(b,i({ref:t},c))}));function b(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=n.length,i=new Array(r);i[0]=m;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[p]="string"==typeof e?e:o,i[1]=l;for(var u=2;u<r;u++)i[u]=n[u];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},4405:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>d,frontMatter:()=>r,metadata:()=>l,toc:()=>u});var a=n(2564),o=(n(9496),n(9613));const r={},i="DoS unbounded operation",l={unversionedId:"vulnerabilities/dos-unbounded-operation",id:"vulnerabilities/dos-unbounded-operation",title:"DoS unbounded operation",description:"Description",source:"@site/docs/vulnerabilities/6-dos-unbounded-operation.md",sourceDirName:"vulnerabilities",slug:"/vulnerabilities/dos-unbounded-operation",permalink:"/scout/docs/vulnerabilities/dos-unbounded-operation",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/vulnerabilities/6-dos-unbounded-operation.md",tags:[],version:"current",sidebarPosition:6,frontMatter:{},sidebar:"docsSidebar",previous:{title:"Unused return enum",permalink:"/scout/docs/vulnerabilities/unused-return-enum"},next:{title:"DoS unexpected revert With vector",permalink:"/scout/docs/vulnerabilities/dos-unexpected-revert-with-vector"}},s={},u=[{value:"Description",id:"description",level:2},{value:"Exploit Scenario",id:"exploit-scenario",level:2},{value:"Deployment",id:"deployment",level:3},{value:"Remediation",id:"remediation",level:2},{value:"References",id:"references",level:2}],c={toc:u},p="wrapper";function d(e){let{components:t,...n}=e;return(0,o.kt)(p,(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"dos-unbounded-operation"},"DoS unbounded operation"),(0,o.kt)("h2",{id:"description"},"Description"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Vulnerability Category: ",(0,o.kt)("inlineCode",{parentName:"li"},"Denial of Service")),(0,o.kt)("li",{parentName:"ul"},"Severity: ",(0,o.kt)("inlineCode",{parentName:"li"},"Medium")),(0,o.kt)("li",{parentName:"ul"},"Detectors: ",(0,o.kt)("a",{parentName:"li",href:"https://github.com/CoinFabrik/scout/tree/main/test-cases/dos-unbounded-operation/dos-unbounded-operation-1"},(0,o.kt)("inlineCode",{parentName:"a"},"dos-unbounded-operation"))),(0,o.kt)("li",{parentName:"ul"},"Test Cases: ",(0,o.kt)("a",{parentName:"li",href:"https://github.com/CoinFabrik/scout/tree/main/test-cases/dos-unbounded-operation/dos-unbounded-operation-1"},(0,o.kt)("inlineCode",{parentName:"a"},"dos-unbounded-operation-1")))),(0,o.kt)("p",null,"Each block in a Substrate Blockchain has an upper bound on the amount of gas\nthat can be spent, and thus the amount computation that can be done. This is\nthe Block Gas Limit. If the gas spent exceeds this limit, the transaction\nwill fail."),(0,o.kt)("p",null,"In this smart contract a malicious user may modify the smart contract's\nconditions so that any transaction coming after will fail, thus imposing\na denial of service for other users."),(0,o.kt)("h2",{id:"exploit-scenario"},"Exploit Scenario"),(0,o.kt)("p",null,"In the following example, a contract has a function ",(0,o.kt)("inlineCode",{parentName:"p"},"add_payee")," that allows\nadding a new element to a vector. The function ",(0,o.kt)("inlineCode",{parentName:"p"},"pay_out")," iterates over the\nvector and transfers the value to the payee's address. The problem is that\nthe ",(0,o.kt)("inlineCode",{parentName:"p"},"pay_out()")," function does not have a fixed number of iterations, and thus\nit can consume all the gas in a block."),(0,o.kt)("p",null,"A malicious user could call ",(0,o.kt)("inlineCode",{parentName:"p"},"add_payee")," a large number of times, thus\npopulating the vector with a large number of elements. Then, the function\n",(0,o.kt)("inlineCode",{parentName:"p"},"pay_out")," when iterating over all the elements, will consume all the gas in\na block, and the transaction will fail, successfully performing a DoS attack."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"/// Adds a new payee to the operation.\n#[ink(message, payable)]\npub fn add_payee(&mut self) -> u128 {\n    let address = self.env().caller();\n    let value = self.env().transferred_value();\n    let new_payee = Payee { address, value };\n\n    self.payees.insert(self.next_payee_ix, &new_payee);\n    self.next_payee_ix = self.next_payee_ix.checked_add(1).unwrap();\n\n    // Return the index of the new payee\n    self.next_payee_ix.checked_sub(1).unwrap()\n}\n")),(0,o.kt)("p",null,"The vulnerable code example can be found ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/CoinFabrik/scout/blob/main/test-cases/dos-unbounded-operation/dos-unbounded-operation-1/vulnerable-example/lib.rs"},"here"),"."),(0,o.kt)("h3",{id:"deployment"},"Deployment"),(0,o.kt)("p",null,"An example can be found under the directory\n",(0,o.kt)("a",{parentName:"p",href:"https://github.com/CoinFabrik/scout/blob/main/test-cases/dos-unbounded-operation/dos-unbounded-operation-1/vulnerable-example"},"vulnerable-example"),". The exploit can be tested by\nrunning the end-to-end test called ",(0,o.kt)("inlineCode",{parentName:"p"},"pay_out_runs_out_of_gas"),"."),(0,o.kt)("h2",{id:"remediation"},"Remediation"),(0,o.kt)("p",null,"The main recommendation is to change the form of payments to favor pull over\npush. This way, the contract does not need to iterate over a vector of payees,\nand thus it does not need to consume all the gas in a block. The payee could\ninstead call a function that will transfer the value to the payee's address."),(0,o.kt)("p",null,"If looping over an array of unknown size is absolutely necessary, then it\nshould be planned to potentially take multiple blocks, and therefore require\nmultiple transactions."),(0,o.kt)("p",null,"The remediated code example can be found ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/CoinFabrik/scout/blob/main/test-cases/dos-unbounded-operation/dos-unbounded-operation-1/remediated-example/lib.rs"},"here"),"."),(0,o.kt)("h2",{id:"references"},"References"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://consensys.github.io/smart-contract-best-practices/attacks/denial-of-service"},"https://consensys.github.io/smart-contract-best-practices/attacks/denial-of-service")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://consensys.github.io/smart-contract-best-practices/development-recommendations/general/external-calls/"},"https://consensys.github.io/smart-contract-best-practices/development-recommendations/general/external-calls/"))))}d.isMDXComponent=!0}}]);