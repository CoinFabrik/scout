"use strict";(self.webpackChunkscout=self.webpackChunkscout||[]).push([[1884],{9613:(e,r,t)=>{t.d(r,{Zo:()=>c,kt:()=>m});var n=t(9496);function a(e,r,t){return r in e?Object.defineProperty(e,r,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[r]=t,e}function i(e,r){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);r&&(n=n.filter((function(r){return Object.getOwnPropertyDescriptor(e,r).enumerable}))),t.push.apply(t,n)}return t}function s(e){for(var r=1;r<arguments.length;r++){var t=null!=arguments[r]?arguments[r]:{};r%2?i(Object(t),!0).forEach((function(r){a(e,r,t[r])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(r){Object.defineProperty(e,r,Object.getOwnPropertyDescriptor(t,r))}))}return e}function o(e,r){if(null==e)return{};var t,n,a=function(e,r){if(null==e)return{};var t,n,a={},i=Object.keys(e);for(n=0;n<i.length;n++)t=i[n],r.indexOf(t)>=0||(a[t]=e[t]);return a}(e,r);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)t=i[n],r.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var l=n.createContext({}),u=function(e){var r=n.useContext(l),t=r;return e&&(t="function"==typeof e?e(r):s(s({},r),e)),t},c=function(e){var r=u(e.components);return n.createElement(l.Provider,{value:r},e.children)},f="mdxType",p={inlineCode:"code",wrapper:function(e){var r=e.children;return n.createElement(n.Fragment,{},r)}},d=n.forwardRef((function(e,r){var t=e.components,a=e.mdxType,i=e.originalType,l=e.parentName,c=o(e,["components","mdxType","originalType","parentName"]),f=u(t),d=a,m=f["".concat(l,".").concat(d)]||f[d]||p[d]||i;return t?n.createElement(m,s(s({ref:r},c),{},{components:t})):n.createElement(m,s({ref:r},c))}));function m(e,r){var t=arguments,a=r&&r.mdxType;if("string"==typeof e||a){var i=t.length,s=new Array(i);s[0]=d;var o={};for(var l in r)hasOwnProperty.call(r,l)&&(o[l]=r[l]);o.originalType=e,o[f]="string"==typeof e?e:a,s[1]=o;for(var u=2;u<i;u++)s[u]=t[u];return n.createElement.apply(null,s)}return n.createElement.apply(null,t)}d.displayName="MDXCreateElement"},4893:(e,r,t)=>{t.r(r),t.d(r,{assets:()=>l,contentTitle:()=>s,default:()=>p,frontMatter:()=>i,metadata:()=>o,toc:()=>u});var n=t(2564),a=(t(9496),t(9613));const i={},s="Unrestricted transfer from",o={unversionedId:"vulnerabilities/unrestricted-transfer-from",id:"vulnerabilities/unrestricted-transfer-from",title:"Unrestricted transfer from",description:"Description",source:"@site/docs/vulnerabilities/14-unrestricted-transfer-from.md",sourceDirName:"vulnerabilities",slug:"/vulnerabilities/unrestricted-transfer-from",permalink:"/scout/docs/vulnerabilities/unrestricted-transfer-from",draft:!1,editUrl:"https://github.com/CoinFabrik/scout/docs/vulnerabilities/14-unrestricted-transfer-from.md",tags:[],version:"current",sidebarPosition:14,frontMatter:{},sidebar:"docsSidebar",previous:{title:"Insufficiently random values",permalink:"/scout/docs/vulnerabilities/insufficiently-random-values"},next:{title:"Detectors",permalink:"/scout/docs/detectors/"}},l={},u=[{value:"Description",id:"description",level:2},{value:"Exploit Scenario",id:"exploit-scenario",level:2},{value:"Remediation",id:"remediation",level:2},{value:"References",id:"references",level:2}],c={toc:u},f="wrapper";function p(e){let{components:r,...t}=e;return(0,a.kt)(f,(0,n.Z)({},c,t,{components:r,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"unrestricted-transfer-from"},"Unrestricted transfer from"),(0,a.kt)("h2",{id:"description"},"Description"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Vulnerability Category: ",(0,a.kt)("inlineCode",{parentName:"li"},"Validations and error handling")),(0,a.kt)("li",{parentName:"ul"},"Vulnerability Severity: ",(0,a.kt)("inlineCode",{parentName:"li"},"Critical")),(0,a.kt)("li",{parentName:"ul"},"Detectors: ",(0,a.kt)("a",{parentName:"li",href:"https://github.com/CoinFabrik/scout/tree/main/detectors/unrestricted-transfer-from"},(0,a.kt)("inlineCode",{parentName:"a"},"unrestricted-transfer-from"))),(0,a.kt)("li",{parentName:"ul"},"Test Cases: ",(0,a.kt)("a",{parentName:"li",href:"https://github.com/CoinFabrik/scout/tree/main/test-cases/unrestricted-transfer-from/unrestricted-transfer-from-1"},(0,a.kt)("inlineCode",{parentName:"a"},"unrestricted-transfer-from-1")))),(0,a.kt)("p",null,"In an ink! Substrate smart contract, allowing unrestricted ",(0,a.kt)("inlineCode",{parentName:"p"},"transfer_from")," operations poses a significant vulnerability. When arguments for such functions are provided directly by the user, this might enable the withdrawal of funds from any actor with token approval on the contract. Specifically, a user could pass the address of an actor with approval as an argument to ",(0,a.kt)("inlineCode",{parentName:"p"},"transfer_from"),", allowing the user to transfer tokens from that actor's balance. This could result in unauthorized transfers and loss of funds. To mitigate this vulnerability, instead of allowing an arbitrary from address, the from address should be restricted, ideally to the address of the caller (",(0,a.kt)("inlineCode",{parentName:"p"},"self.env().caller()"),"), ensuring that only the sender can initiate a transfer."),(0,a.kt)("h2",{id:"exploit-scenario"},"Exploit Scenario"),(0,a.kt)("p",null,"Consider the following ",(0,a.kt)("inlineCode",{parentName:"p"},"ink!")," contract:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},'#[ink(message)]\npub fn deposit(&mut self, from: AccountId) -> Result<(), Error>{\n    if self.env().caller() != self.buyer {\n        return Err(Error::CallerMustBeBuyer)\n    } else if self.status != Status::Created {\n        return Err(Error::StatusMustBeCreated)\n    } else {\n        // 0x54b3c76e selector comes from https://github.com/w3f/PSPs/blob/master/PSPs/psp-22.md\n        let call_params = build_call::<DefaultEnvironment>()\n            .exec_input(\n                ExecutionInput::new(Selector::new(ink::selector_bytes!(\n                    "PSP22::transfer_from"\n                )))\n                .push_arg(from)\n                .push_arg(self.env().account_id())\n                .push_arg(self.amount)\n                .push_arg([0u8])\n            )\n            .returns::<Result<(),PSP22Error>>()\n            .call(self.psp22_address)\n            .params();\n        let res = self.env().invoke_contract(&call_params)\n            .unwrap_or_else(|err| panic!("Err {:?}", err))\n            .unwrap_or_else(|err| panic!("LangErr {:?}", err))\n            .map_err(|err| Error::PSP22Error(err));\n        if res.is_ok() {\n            self.status = Status::Locked;\n        }\n        return res;\n    }\n}\n')),(0,a.kt)("p",null,"The deposit function in this example exhibits a vulnerability due to the unrestricted use of the from argument in the ",(0,a.kt)("inlineCode",{parentName:"p"},"PSP22::transfer_from")," call. This argument is provided by the user and could refer to any account that has token approval on the contract. Consequently, a user can perform an unauthorized withdrawal from an account that didn't intend to make a deposit, resulting in potential loss of funds. Therefore, unrestricted ",(0,a.kt)("inlineCode",{parentName:"p"},"transfer_from")," operations can be a serious security risk, as they allow manipulation of the ",(0,a.kt)("inlineCode",{parentName:"p"},"from")," parameter, enabling undesired transfers."),(0,a.kt)("p",null,"The vulnerable code example can be found ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/CoinFabrik/scout/tree/main/test-cases/unrestricted-transfer-from/unrestricted-transfer-from-1/vulnerable-example"},(0,a.kt)("inlineCode",{parentName:"a"},"here")),"."),(0,a.kt)("h2",{id:"remediation"},"Remediation"),(0,a.kt)("p",null,"In order to remediate this issue, avoid using function parameters as input for the ",(0,a.kt)("inlineCode",{parentName:"p"},"transfer_from")," function."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},'#[ink(message)]\npub fn deposit(&mut self) -> Result<(), Error>{\n    if self.env().caller() != self.buyer {\n        return Err(Error::CallerMustBeBuyer)\n    } else if self.status != Status::Created {\n        return Err(Error::StatusMustBeCreated)\n    } else {\n        // 0x54b3c76e selector comes from https://github.com/w3f/PSPs/blob/master/PSPs/psp-22.md\n        let call_params = build_call::<DefaultEnvironment>()\n            .exec_input(\n                ExecutionInput::new(Selector::new(ink::selector_bytes!(\n                    "PSP22::transfer_from"\n                )))\n                .push_arg(self.env().caller())\n                .push_arg(self.env().account_id())\n                .push_arg(self.amount)\n                .push_arg([0u8])\n            )\n            .returns::<Result<(),PSP22Error>>()\n            .call(self.psp22_address)\n            .params();\n        let res = self.env().invoke_contract(&call_params)\n            .unwrap_or_else(|err| panic!("Err {:?}", err))\n            .unwrap_or_else(|err| panic!("LangErr {:?}", err))\n            .map_err(|err| Error::PSP22Error(err));\n        if res.is_ok() {\n            self.status = Status::Locked;\n        }\n        return res;\n    }\n\n}\n')),(0,a.kt)("p",null,"The vulnerability was addressed in the remediated deposit function by removing the arbitrary from argument and replacing it with ",(0,a.kt)("inlineCode",{parentName:"p"},"self.env().caller()"),". This change ensures that the ",(0,a.kt)("inlineCode",{parentName:"p"},"transfer_from")," function is called only with the account of the caller, thereby eliminating the risk of unauthorized token transfers. The remediation restricts ",(0,a.kt)("inlineCode",{parentName:"p"},"transfer_from")," operations to the caller, significantly reducing the potential for malicious manipulation by confining token transfers to the initiating user's account. This enforces a safeguard where only the user invoking the function can transfer tokens from their account to the contract, thus ensuring the secure execution of the contract."),(0,a.kt)("h2",{id:"references"},"References"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://github.com/crytic/slither/wiki/Detector-Documentation#arbitrary-from-in-transferfrom"},"Slither: Arbitrary from in transfer from"))))}p.isMDXComponent=!0}}]);