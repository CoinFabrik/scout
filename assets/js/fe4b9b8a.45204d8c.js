"use strict";(self.webpackChunkscout=self.webpackChunkscout||[]).push([[2148],{9613:(e,t,n)=>{n.d(t,{Zo:()=>l,kt:()=>m});var a=n(9496);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function d(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var i=a.createContext({}),c=function(e){var t=a.useContext(i),n=t;return e&&(n="function"==typeof e?e(t):d(d({},t),e)),n},l=function(e){var t=c(e.components);return a.createElement(i.Provider,{value:t},e.children)},u="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},f=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,i=e.parentName,l=s(e,["components","mdxType","originalType","parentName"]),u=c(n),f=r,m=u["".concat(i,".").concat(f)]||u[f]||p[f]||o;return n?a.createElement(m,d(d({ref:t},l),{},{components:n})):a.createElement(m,d({ref:t},l))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,d=new Array(o);d[0]=f;var s={};for(var i in t)hasOwnProperty.call(t,i)&&(s[i]=t[i]);s.originalType=e,s[u]="string"==typeof e?e:r,d[1]=s;for(var c=2;c<o;c++)d[c]=n[c];return a.createElement.apply(null,d)}return a.createElement.apply(null,n)}f.displayName="MDXCreateElement"},1364:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>i,contentTitle:()=>d,default:()=>p,frontMatter:()=>o,metadata:()=>s,toc:()=>c});var a=n(2564),r=(n(9496),n(9613));const o={},d="DoS Unexpected Revert With Vector",s={unversionedId:"vulnerabilities/dos-unexpected-revert-with-vector",id:"vulnerabilities/dos-unexpected-revert-with-vector",title:"DoS Unexpected Revert With Vector",description:"Description",source:"@site/docs/vulnerabilities/7-dos-unexpected-revert-with-vector.md",sourceDirName:"vulnerabilities",slug:"/vulnerabilities/dos-unexpected-revert-with-vector",permalink:"/scout/docs/vulnerabilities/dos-unexpected-revert-with-vector",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/vulnerabilities/7-dos-unexpected-revert-with-vector.md",tags:[],version:"current",sidebarPosition:7,frontMatter:{},sidebar:"docsSidebar",previous:{title:"DoS Unbounded Operation",permalink:"/scout/docs/vulnerabilities/dos-unbounded-operation"},next:{title:"Detectors",permalink:"/scout/docs/detectors/"}},i={},c=[{value:"Description",id:"description",level:2},{value:"Exploit Scenario",id:"exploit-scenario",level:2},{value:"Deployment (of the vulnerable contract)",id:"deployment-of-the-vulnerable-contract",level:3},{value:"Remediation",id:"remediation",level:2},{value:"Deployment (of the remediated contract)",id:"deployment-of-the-remediated-contract",level:3},{value:"References",id:"references",level:2}],l={toc:c},u="wrapper";function p(e){let{components:t,...n}=e;return(0,r.kt)(u,(0,a.Z)({},l,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"dos-unexpected-revert-with-vector"},"DoS Unexpected Revert With Vector"),(0,r.kt)("h2",{id:"description"},"Description"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Vulnerability Category: ",(0,r.kt)("inlineCode",{parentName:"li"},"DoS")),(0,r.kt)("li",{parentName:"ul"},"Severity: ",(0,r.kt)("inlineCode",{parentName:"li"},"High")),(0,r.kt)("li",{parentName:"ul"},"Detectors: ",(0,r.kt)("a",{parentName:"li",href:"https://github.com/CoinFabrik/scout/tree/main/detectors/dos-unexpected-revert-with-vector"},(0,r.kt)("inlineCode",{parentName:"a"},"dos-unexpected-revert-with-vector"))),(0,r.kt)("li",{parentName:"ul"},"Test Cases: ",(0,r.kt)("a",{parentName:"li",href:"https://github.com/CoinFabrik/scout/tree/main/test-cases/dos-unexpected-revert-with-vector/dos-unexpected-revert-with-vector-1"},(0,r.kt)("inlineCode",{parentName:"a"},"dos-unexpected-revert-with-vector-1")))),(0,r.kt)("p",null,"This vulnerability of DoS through unexpected revert arises when a smart\ncontract does not handle storage size errors correctly, and a user can add an\nexcessive number of entries, leading to an unexpected revert of transactions\nby other users and a Denial of Service. This vulnerability can be exploited by\nan attacker to perform a DoS attack on the network and can result in lost\nfunds, poor user experience, and even harm the network's overall security."),(0,r.kt)("h2",{id:"exploit-scenario"},"Exploit Scenario"),(0,r.kt)("p",null,"The vulnerable smart contract we developed for his example allows users to\nvote for one of different candidates.\nThe smart contract contains a struct named ",(0,r.kt)("inlineCode",{parentName:"p"},"UnexpectedRevert")," that stores the\ntotal number of votes, a list of candidates, their votes, and whether an\naccount has voted. It also stores information about the most voted candidate\nand when the vote will end."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'#![cfg_attr(not(feature = "std"), no_std)]\n\n#[ink::contract]\nmod unexpected_revert {\n    use ink::prelude::vec::Vec;\n    use ink::storage::Mapping;\n\n    #[ink(storage)]\n    pub struct UnexpectedRevert {\n        /// Total votes performed.\n        total_votes: u64,\n        /// List of candidates.\n        candidates: Vec<AccountId>,\n        /// Votes for each candidate.\n        votes: Mapping<AccountId, u64>,\n        /// Accounts that already voted.\n        already_voted: Mapping<AccountId, bool>,\n        /// Account id of the most voted candidate.\n        most_voted_candidate: AccountId,\n        /// Votes of the most voted candidate.\n        candidate_votes: u64,\n        /// Timestamp when the vote ends.\n        vote_timestamp_end: u64,\n    }\n\n    #[derive(Debug, PartialEq, Eq, Clone, scale::Encode, scale::Decode)]\n    #[cfg_attr(feature = "std", derive(::scale_info::TypeInfo))]\n    pub enum Errors {\n        /// Account already voted.\n        AccountAlreadyVoted,\n        /// Candidate already added.\n        CandidateAlreadyAdded,\n        /// Candidate doesn\'t exist.\n        CandidateDoesntExist,\n        /// Overflow was detected.\n        Overflow,\n        /// Timestamp before current block.\n        TimestampBeforeCurrentBlock,\n        /// Vote ended.\n        VoteEnded,\n    }\n\n    impl UnexpectedRevert {\n        /// Constructor that initializes the `bool` value to the given `init_value`.\n        #[ink(constructor)]\n        pub fn new(end_timestamp: u64) -> Result<Self, Errors> {\n            if end_timestamp <= Self::env().block_timestamp() {\n                return Err(Errors::TimestampBeforeCurrentBlock);\n            }\n\n            let zero_arr: [u8; 32] = [0; 32];\n            let zero_addr = AccountId::from(zero_arr);\n            Ok(Self {\n                total_votes: 0,\n                most_voted_candidate: zero_addr,\n                candidate_votes: 0,\n                candidates: Vec::default(),\n                already_voted: Mapping::default(),\n                votes: Mapping::default(),\n                vote_timestamp_end: end_timestamp,\n            })\n        }\n\n        /// Adds a candidate to this vote.\n        #[ink(message)]\n        pub fn add_candidate(&mut self, candidate: AccountId) -> Result<(), Errors> {\n            if self.vote_ended() {\n                return Err(Errors::VoteEnded);\n            }\n            if self.votes.contains(candidate) {\n                Err(Errors::CandidateAlreadyAdded)\n            } else {\n                self.candidates.push(candidate);\n                self.votes.insert(candidate, &0);\n                Ok(())\n            }\n        }\n\n        /// Returns votes for a given candidate.\n        #[ink(message)]\n        pub fn get_votes_for_a_candidate(&self, candidate: AccountId) -> Result<u64, Errors> {\n            let votes_opt = self.votes.get(candidate);\n            if votes_opt.is_none() {\n                Err(Errors::CandidateDoesntExist)\n            } else {\n                Ok(votes_opt.unwrap())\n            }\n        }\n\n        /// Returns votes for the most voted candidate.\n        #[ink(message)]\n        pub fn most_voted_candidate_votes(&self) -> u64 {\n            self.candidate_votes\n        }\n\n        /// Returns account id for the most voted candidate.\n        #[ink(message)]\n        pub fn most_voted_candidate(&self) -> AccountId {\n            self.most_voted_candidate\n        }\n\n        /// Returns total votes performed.\n        #[ink(message)]\n        pub fn get_total_votes(&self) -> u64 {\n            self.total_votes\n        }\n\n        /// Returns total candidates.\n        #[ink(message)]\n        pub fn get_total_candidates(&self) -> u64 {\n            self.candidates.len() as u64\n        }\n\n        /// Returns candidate at index.\n        #[ink(message)]\n        pub fn get_candidate(&self, index: u64) -> Result<AccountId, Errors> {\n            if (index as usize) < self.candidates.len() {\n                Ok(self.candidates[index as usize])\n            } else {\n                Err(Errors::CandidateDoesntExist)\n            }\n        }\n\n        /// Returns true if the account has already voted.\n        #[ink(message)]\n        pub fn account_has_voted(&self, account: AccountId) -> bool {\n            self.already_voted.get(account).unwrap_or(false)\n        }\n\n        /// Vote for one of the candidates.\n        #[ink(message)]\n        pub fn vote(&mut self, candidate: AccountId) -> Result<(), Errors> {\n            if self.vote_ended() {\n                return Err(Errors::VoteEnded);\n            }\n            let caller = self.env().caller();\n            if self.already_voted.contains(caller) {\n                Err(Errors::AccountAlreadyVoted)\n            } else {\n                self.already_voted.insert(caller, &true);\n                let votes = self\n                    .votes\n                    .get(candidate)\n                    .ok_or(Errors::CandidateDoesntExist)?\n                    .checked_add(1)\n                    .ok_or(Errors::Overflow)?;\n                self.votes.insert(candidate, &votes);\n                self.total_votes.checked_add(1).ok_or(Errors::Overflow)?;\n                if self.candidate_votes < votes {\n                    self.candidate_votes = votes;\n                    self.most_voted_candidate = candidate;\n                }\n                Ok(())\n            }\n        }\n\n        /// Returns true if the vote has ended.\n        #[ink(message)]\n        pub fn vote_ended(&self) -> bool {\n            self.vote_timestamp_end <= self.env().block_timestamp()\n        }\n    }\n\n    #[cfg(test)]\n    mod tests {\n        use super::*;\n        use std::time::SystemTime;\n\n        #[ink::test]\n        fn insert_512_candidates() {\n            let now: u64 = match SystemTime::now().duration_since(SystemTime::UNIX_EPOCH) {\n                Ok(n) => (n.as_secs() + 10 * 60) * 1000,\n                Err(_) => panic!("SystemTime before UNIX EPOCH!"),\n            };\n            let mut contract = UnexpectedRevert::new(now).unwrap();\n\n            let mut candidate: Result<(), Errors> = Err(Errors::VoteEnded);\n            for i in 0u32..512 {\n                let mut zero_vec = vec![0u8; 28];\n                zero_vec.extend(i.to_be_bytes().iter().cloned());\n                let arr: [u8; 32] = match zero_vec.as_slice().try_into() {\n                    Ok(arr) => arr,\n                    Err(_) => panic!(),\n                };\n                let addr = AccountId::from(arr);\n                candidate = contract.add_candidate(addr);\n                assert_eq!(contract.get_total_candidates(), (i + 1) as u64);\n            }\n\n            assert_eq!(contract.get_total_candidates(), 512u64);\n            assert_eq!(candidate.is_ok(), true);\n        }\n    }\n\n    #[cfg(all(test, feature = "e2e-tests"))]\n    mod e2e_tests {\n        use super::*;\n        use ink_e2e::build_message;\n        use std::time::SystemTime;\n\n        #[ink_e2e::test]\n        #[should_panic(expected = "add_candidate failed: CallDryRun")]\n        async fn insert_512_candidates(mut client: ink_e2e::Client<C, E>) {\n            let now: u64 = match SystemTime::now().duration_since(SystemTime::UNIX_EPOCH) {\n                Ok(n) => (n.as_secs() + 10 * 60) * 1000,\n                Err(_) => panic!("SystemTime before UNIX EPOCH!"),\n            };\n            let constructor = UnexpectedRevertRef::new(now);\n            let contract_acc_id = client\n                .instantiate("unexpected-revert", &ink_e2e::alice(), constructor, 0, None)\n                .await\n                .expect("instantiate failed")\n                .account_id;\n\n            for i in 0u32..512 {\n                let mut zero_vec = vec![0u8; 28];\n                zero_vec.extend(i.to_be_bytes().iter().cloned());\n                let arr: [u8; 32] = match zero_vec.as_slice().try_into() {\n                    Ok(arr) => arr,\n                    Err(_) => panic!(),\n                };\n                let addr = AccountId::from(arr);\n\n                let add_candidate = build_message::<UnexpectedRevertRef>(contract_acc_id.clone())\n                    .call(|contract| contract.add_candidate(addr));\n                client\n                    .call(&ink_e2e::bob(), add_candidate.clone(), 0, None)\n                    .await\n                    .expect("add_candidate failed");\n            }\n        }\n    }\n}\n')),(0,r.kt)("p",null,"The smart contract has several functions that allow adding a candidate, getting\nvotes for a specific candidate, getting the account ID of the most voted\ncandidate, getting the total votes, getting the total number of candidates,\ngetting a candidate by index, checking if an account has voted, and voting for\na candidate."),(0,r.kt)("p",null,"The #","[cfg(test)]"," block contains a single test that adds 512 candidates to the\nsmart contract. It initializes the contract with the current timestamp + 10\nminutes and then uses a loop to add each candidate. The test verifies that\nthe function to add a candidate fails with an error indicating that the vote\nhas ended. The purpose of this test is to trigger an unexpected revert due\nto the contract's storage size, but this does not occur since the deployment\nis mocked and does not check the size of storage cells."),(0,r.kt)("p",null,"On the other hand, the end to end test instantiates the contract using\n",(0,r.kt)("inlineCode",{parentName:"p"},"ink_e2e::alice()")," as the deployer account and an ",(0,r.kt)("inlineCode",{parentName:"p"},"UnexpectedRevertRef"),"\ninstance with a specified now value. It then uses a loop to add 512 candidates\nto the contract by calling the add_candidate function for each candidate\naccount."),(0,r.kt)("p",null,"The loop generates a unique ",(0,r.kt)("inlineCode",{parentName:"p"},"AccountId")," for each candidate by creating a\nvector of 28 zeroes, appending the current index as a big-endian byte array,\nand converting the resulting vector to a fixed-length array of 32 bytes."),(0,r.kt)("p",null,"The test expects the ",(0,r.kt)("inlineCode",{parentName:"p"},"add_candidate()")," function to fail with a ",(0,r.kt)("inlineCode",{parentName:"p"},"CallDryRun")," error,\nwhich indicates that the transaction execution failed during a dry run. This\nis indicated by the ",(0,r.kt)("inlineCode",{parentName:"p"},'#[should_panic(expected = "add_candidate failed: CallDryRun")]'),"\nattribute on the test function. This test ",(0,r.kt)("em",{parentName:"p"},"does")," trigger an unexpected revert\ndue to the contract's storage size."),(0,r.kt)("p",null,"The vulnerable code example can be found ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/CoinFabrik/scout/blob/main/test-cases/dos-unexpected-revert-with-vector/dos-unexpected-revert-with-vector-1/vulnerable-example/lib.rs"},"here"),"."),(0,r.kt)("h3",{id:"deployment-of-the-vulnerable-contract"},"Deployment (of the vulnerable contract)"),(0,r.kt)("p",null,"In order to run the tests associated to this contract and view this\nvulnerability in action:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Save the ",(0,r.kt)("inlineCode",{parentName:"li"},"vulnerable-example")," directory."),(0,r.kt)("li",{parentName:"ol"},"Run a substrate node and save its ",(0,r.kt)("inlineCode",{parentName:"li"},"FULL_PATH"),"."),(0,r.kt)("li",{parentName:"ol"},"Open a new terminal at the ",(0,r.kt)("inlineCode",{parentName:"li"},"vulnerable-example")," directory and set the\ncontract node environmental variable by running:\n",(0,r.kt)("inlineCode",{parentName:"li"},"export CONTRACTS_NODE=[FULL_PATH]")),(0,r.kt)("li",{parentName:"ol"},"Finally, run the test with:\n",(0,r.kt)("inlineCode",{parentName:"li"},"cargo test --features e2e-tests"))),(0,r.kt)("p",null,"You should see that the vulnerability is not realized for the integration test\nsince the deployment is mocked and does not check the size of storage cells,\nbut it is for the e2e-test."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"$ cargo test --features e2e-tests\n\n    Updating crates.io index\n  Downloaded toml_edit v0.19.7\n\n  ...\n\n   Compiling metadata-gen v0.1.0 (/tmp/cargo-contract_5urX7T/.ink/metadata_gen)\n    Finished release [optimized] target(s) in 1m 06s\n     Running `target/ink/release/metadata-gen`\n [5/5] Generating bundle\n    Finished test [unoptimized + debuginfo] target(s) in 15m 02s\n     Running unittests lib.rs (target/debug/deps/unexpected_revert-feae385052f36b92)\n\nrunning 2 tests\ntest unexpected_revert::tests::insert_512_candidates ... ok\ntest unexpected_revert::e2e_tests::insert_512_candidates - should panic ... ok\n\ntest result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 59.94s\n\n   Doc-tests unexpected-revert\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n")),(0,r.kt)("h2",{id:"remediation"},"Remediation"),(0,r.kt)("p",null,"In order to prevent this vulnerability we discourage the use of ",(0,r.kt)("inlineCode",{parentName:"p"},"Vec")," and\npropose the use of ",(0,r.kt)("inlineCode",{parentName:"p"},"Mapping")," in order to avoid storage limits in the list of candidates."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'#![cfg_attr(not(feature = "std"), no_std)]\n\n#[ink::contract]\nmod unexpected_revert {\n    use ink::storage::Mapping;\n    #[ink(storage)]\n    pub struct UnexpectedRevert {\n        /// Total votes performed.\n        total_votes: u64,\n        /// Total candidates.\n        total_candidates: u64,\n        /// List of candidates.\n        candidates: Mapping<u64, AccountId>,\n        /// Votes for each candidate.\n        votes: Mapping<AccountId, u64>,\n        /// Accounts that already voted.\n        already_voted: Mapping<AccountId, bool>,\n        /// Account id of the most voted candidate.\n        most_voted_candidate: AccountId,\n        /// Votes of the most voted candidate\n        candidate_votes: u64,\n        /// Timestamp when the vote ends.\n        vote_timestamp_end: u64,\n    }\n\n    #[derive(Debug, PartialEq, Eq, Clone, scale::Encode, scale::Decode)]\n    #[cfg_attr(feature = "std", derive(::scale_info::TypeInfo))]\n    pub enum Errors {\n        /// Account already voted.\n        AccountAlreadyVoted,\n        /// Candidate already added.\n        CandidateAlreadyAdded,\n        /// Candidate doesn\'t exist.\n        CandidateDoesntExist,\n        /// Overflow was detected.\n        Overflow,\n        /// Timestamp before current block.\n        TimestampBeforeCurrentBlock,\n        /// Vote ended.\n        VoteEnded,\n    }\n\n    impl UnexpectedRevert {\n        /// Constructor that initializes the `bool` value to the given `init_value`.\n        #[ink(constructor)]\n        pub fn new(end_timestamp: u64) -> Result<Self, Errors> {\n            if end_timestamp <= Self::env().block_timestamp() {\n                return Err(Errors::TimestampBeforeCurrentBlock);\n            }\n            let zero_arr: [u8; 32] = [0; 32];\n            let zero_addr = AccountId::from(zero_arr);\n            Ok(Self {\n                total_votes: 0,\n                total_candidates: 0,\n                most_voted_candidate: zero_addr,\n                candidate_votes: 0,\n                candidates: Mapping::default(),\n                already_voted: Mapping::default(),\n                votes: Mapping::default(),\n                vote_timestamp_end: end_timestamp,\n            })\n        }\n\n        /// Add a candidate to this vote\n        #[ink(message)]\n        pub fn add_candidate(&mut self, candidate: AccountId) -> Result<(), Errors> {\n            if self.vote_ended() {\n                return Err(Errors::VoteEnded);\n            }\n            if self.votes.contains(candidate) {\n                Err(Errors::CandidateAlreadyAdded)\n            } else {\n                self.candidates.insert(self.total_candidates, &candidate);\n                self.total_candidates += 1;\n                self.votes.insert(candidate, &0);\n                Ok(())\n            }\n        }\n\n        /// Returns votes for a given candidate.\n        #[ink(message)]\n        pub fn get_votes_for_a_candidate(&self, candidate: AccountId) -> Result<u64, Errors> {\n            let votes_opt = self.votes.get(candidate);\n            if votes_opt.is_none() {\n                Err(Errors::CandidateDoesntExist)\n            } else {\n                Ok(votes_opt.unwrap())\n            }\n        }\n\n        /// Returns votes for the most voted candidate.\n        #[ink(message)]\n        pub fn most_voted_candidate_votes(&self) -> u64 {\n            self.candidate_votes\n        }\n\n        /// Returns account id for the most voted candidate.\n        #[ink(message)]\n        pub fn most_voted_candidate(&self) -> AccountId {\n            self.most_voted_candidate\n        }\n\n        /// Returns total votes performed.\n        #[ink(message)]\n        pub fn get_total_votes(&self) -> u64 {\n            self.total_votes\n        }\n\n        /// Returns total candidates.\n        #[ink(message)]\n        pub fn get_total_candidates(&self) -> u64 {\n            self.total_candidates\n        }\n\n        /// Returns candidate at index.\n        #[ink(message)]\n        pub fn get_candidate(&self, index: u64) -> Result<AccountId, Errors> {\n            match self.candidates.get(index) {\n                Some(candidate) => Ok(candidate),\n                None => Err(Errors::CandidateDoesntExist),\n            }\n        }\n\n        /// Returns true if the account has already voted.\n        #[ink(message)]\n        pub fn account_has_voted(&self, account: AccountId) -> bool {\n            self.already_voted.get(account).unwrap_or(false)\n        }\n\n        /// Vote for one of the candidates.\n        #[ink(message)]\n        pub fn vote(&mut self, candidate: AccountId) -> Result<(), Errors> {\n            if self.vote_ended() {\n                return Err(Errors::VoteEnded);\n            }\n            let caller = self.env().caller();\n            if self.already_voted.contains(caller) {\n                Err(Errors::AccountAlreadyVoted)\n            } else {\n                self.already_voted.insert(caller, &true);\n                let votes = self\n                    .votes\n                    .get(candidate)\n                    .ok_or(Errors::CandidateDoesntExist)?\n                    .checked_add(1)\n                    .ok_or(Errors::Overflow)?;\n                self.votes.insert(candidate, &votes);\n                self.total_votes.checked_add(1).ok_or(Errors::Overflow)?;\n                if self.candidate_votes < votes {\n                    self.candidate_votes = votes;\n                    self.most_voted_candidate = candidate;\n                }\n                Ok(())\n            }\n        }\n\n        /// Returns true if the vote has ended.\n        #[ink(message)]\n        pub fn vote_ended(&self) -> bool {\n            self.vote_timestamp_end <= self.env().block_timestamp()\n        }\n    }\n\n    #[cfg(test)]\n    mod tests {\n        use super::*;\n        use std::time::SystemTime;\n\n        #[ink::test]\n        fn insert_512_candidates() {\n            let now: u64 = match SystemTime::now().duration_since(SystemTime::UNIX_EPOCH) {\n                Ok(n) => (n.as_secs() + 10 * 60) * 1000,\n                Err(_) => panic!("SystemTime before UNIX EPOCH!"),\n            };\n            let mut contract = UnexpectedRevert::new(now).unwrap();\n\n            let mut candidate: Result<(), Errors> = Err(Errors::VoteEnded);\n            for i in 0u32..512 {\n                let mut zero_vec = vec![0u8; 28];\n                zero_vec.extend(i.to_be_bytes().iter().cloned());\n                let arr: [u8; 32] = match zero_vec.as_slice().try_into() {\n                    Ok(arr) => arr,\n                    Err(_) => panic!(),\n                };\n                let addr = AccountId::from(arr);\n                candidate = contract.add_candidate(addr);\n                assert_eq!(contract.get_total_candidates(), (i + 1) as u64);\n            }\n\n            assert_eq!(contract.get_total_candidates(), 512u64);\n            assert_eq!(candidate.is_ok(), true);\n        }\n    }\n\n    #[cfg(all(test, feature = "e2e-tests"))]\n    mod e2e_tests {\n        use super::*;\n        use ink_e2e::build_message;\n        use std::time::SystemTime;\n\n        #[ink_e2e::test]\n        async fn insert_512_candidates(mut client: ink_e2e::Client<C, E>) {\n            let now: u64 = match SystemTime::now().duration_since(SystemTime::UNIX_EPOCH) {\n                Ok(n) => (n.as_secs() + 10 * 60) * 1000,\n                Err(_) => panic!("SystemTime before UNIX EPOCH!"),\n            };\n            let constructor = UnexpectedRevertRef::new(now);\n            let contract_acc_id = client\n                .instantiate("unexpected-revert", &ink_e2e::alice(), constructor, 0, None)\n                .await\n                .expect("instantiate failed")\n                .account_id;\n\n            for i in 0u32..512 {\n                let mut zero_vec = vec![0u8; 28];\n                zero_vec.extend(i.to_be_bytes().iter().cloned());\n                let arr: [u8; 32] = match zero_vec.as_slice().try_into() {\n                    Ok(arr) => arr,\n                    Err(_) => panic!(),\n                };\n                let addr = AccountId::from(arr);\n\n                let add_candidate = build_message::<UnexpectedRevertRef>(contract_acc_id.clone())\n                    .call(|contract| contract.add_candidate(addr));\n                client\n                    .call(&ink_e2e::bob(), add_candidate.clone(), 0, None)\n                    .await\n                    .expect("add_candidate failed");\n            }\n            let get_total_candidates =\n                build_message::<UnexpectedRevertRef>(contract_acc_id.clone())\n                    .call(|contract| contract.get_total_candidates());\n            let candidates_count = client\n                .call(&ink_e2e::bob(), get_total_candidates.clone(), 0, None)\n                .await\n                .expect("candidates_count failed");\n            assert_eq!(candidates_count.return_value(), 512);\n        }\n    }\n}\n')),(0,r.kt)("p",null,"The remediated code example can be found ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/CoinFabrik/scout/blob/main/test-cases/dos-unexpected-revert-with-vector/dos-unexpected-revert-with-vector-1/remediated-example/lib.rs"},"here"),"."),(0,r.kt)("h3",{id:"deployment-of-the-remediated-contract"},"Deployment (of the remediated contract)"),(0,r.kt)("p",null,"In order to run the tests associated to this remediated contract in action:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Save the ",(0,r.kt)("inlineCode",{parentName:"li"},"remediated-example")," directory."),(0,r.kt)("li",{parentName:"ol"},"Run a substrate node and save its ",(0,r.kt)("inlineCode",{parentName:"li"},"FULL_PATH"),"."),(0,r.kt)("li",{parentName:"ol"},"Open a new terminal at the ",(0,r.kt)("inlineCode",{parentName:"li"},"vulnerable-example")," directory and set the contract node environmental variable by running:\n",(0,r.kt)("inlineCode",{parentName:"li"},"export CONTRACTS_NODE=[FULL_PATH]")),(0,r.kt)("li",{parentName:"ol"},"Finally, run the test with:\n",(0,r.kt)("inlineCode",{parentName:"li"},"cargo test --features e2e-tests"))),(0,r.kt)("p",null,"You should see that the vulnerability is not realized for any of the tests."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"$ cargo test --features e2e-tests\n\n    Updating crates.io index\n    Compiling unicode-ident v1.0.8\n\n    ...\n\n [5/5] Generating bundle\n    Finished test [unoptimized + debuginfo] target(s) in 14m 24s\n     Running unittests lib.rs (target/debug/deps/unexpected_revert-feae385052f36b92)\n\nrunning 2 tests\ntest unexpected_revert::tests::insert_512_candidates ... ok\ntest unexpected_revert::e2e_tests::insert_512_candidates ... ok\n\ntest result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 46.06s\n\n   Doc-tests unexpected-revert\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n")),(0,r.kt)("h2",{id:"references"},"References"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://swcregistry.io/docs/SWC-113"},"SWC-113")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://consensys.github.io/smart-contract-best-practices/attacks/denial-of-service/#dos-with-unexpected-revert"},"https://consensys.github.io/smart-contract-best-practices/attacks/denial-of-service/#dos-with-unexpected-revert")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://ethernaut.openzeppelin.com/level/0x43BA674B4fbb8B157b7441C2187bCdD2cdF84FD5"},"Ethernaut: King"))))}p.isMDXComponent=!0}}]);